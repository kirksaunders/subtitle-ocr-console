// This code is generated by rnet (a Rust crate for generating C#/Rust interop code)
// Hence, all warnings have been disabled

#pragma warning disable CS8765, CS8767, CS8604, CS8607, CS8603

using System.Runtime.InteropServices;
using System.Text;

namespace subtitle_ocr_console.OCR.Decoders;

public static class CTCBeamDecoderExternal
{
    public class RustException : Exception
    {
        public RustException(string message) : base(message) { }
    }

    public interface IOpaqueHandle : IEquatable<IOpaqueHandle>, IDisposable { }


    public struct DecoderOutput
    {
        public List<int> sequences;
        public List<int> lengths;
    }
    public static DecoderOutput Decode(
        IReadOnlyCollection<float> predictions,
        IReadOnlyCollection<int> lengths,
        int numClasses,
        int beamWidth,
        int blankIdx
    )
    {
        return (_FnDecode(_AllocSlice<float, float>(predictions, 4, 4, _arg1 => _arg1), _AllocSlice<int, int>(lengths, 4, 4, _arg2 => _arg2), numClasses, beamWidth, blankIdx)).Decode();
    }
    public static DecoderOutput DecodeWithLm(
        IReadOnlyCollection<float> predictions,
        IReadOnlyCollection<int> lengths,
        int numClasses,
        int beamWidth,
        int blankIdx,
        IReadOnlyCollection<float> firstCharProbs,
        IReadOnlyCollection<float> secondCharProbs,
        float lmWeight,
        float lmMinProb
    )
    {
        return (_FnDecodeWithLm(_AllocSlice<float, float>(predictions, 4, 4, _arg3 => _arg3), _AllocSlice<int, int>(lengths, 4, 4, _arg4 => _arg4), numClasses, beamWidth, blankIdx, _AllocSlice<float, float>(firstCharProbs, 4, 4, _arg5 => _arg5), _AllocSlice<float, float>(secondCharProbs, 4, 4, _arg6 => _arg6), lmWeight, lmMinProb)).Decode();
    }
    [StructLayout(LayoutKind.Sequential)]
    private struct _StructDecoderOutput
    {
        public _RawSlice sequences;
        public _RawSlice lengths;
        public static _StructDecoderOutput Encode(DecoderOutput structArg)
        {
            return new _StructDecoderOutput
            {
                sequences = _AllocSlice<int, int>(structArg.sequences, 4, 4, _arg7 => _arg7),
                lengths = _AllocSlice<int, int>(structArg.lengths, 4, 4, _arg8 => _arg8)
            };
        }
        public DecoderOutput Decode()
        {
            return new DecoderOutput
            {
                sequences = _FreeSlice<int, int, List<int>>(this.sequences, 4, 4, _arg9 => _arg9),
                lengths = _FreeSlice<int, int, List<int>>(this.lengths, 4, 4, _arg10 => _arg10)
            };
        }
    }
    [DllImport("ctc_beam_decoder", EntryPoint = "rnet_export_decode", CallingConvention = CallingConvention.Cdecl)]
    private static extern _StructDecoderOutput _FnDecode(
        _RawSlice predictions,
        _RawSlice lengths,
        int numClasses,
        int beamWidth,
        int blankIdx
    );
    [DllImport("ctc_beam_decoder", EntryPoint = "rnet_export_decode_with_lm", CallingConvention = CallingConvention.Cdecl)]
    private static extern _StructDecoderOutput _FnDecodeWithLm(
        _RawSlice predictions,
        _RawSlice lengths,
        int numClasses,
        int beamWidth,
        int blankIdx,
        _RawSlice firstCharProbs,
        _RawSlice secondCharProbs,
        float lmWeight,
        float lmMinProb
    );


    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void _ManageDelegateDelegate(IntPtr ptr, int adjust);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void _DropOpaqueDelegate(IntPtr ptr);

    private static Dictionary<IntPtr, (int, Delegate, Delegate)> _ActiveDelegates = new Dictionary<IntPtr, (int, Delegate, Delegate)>();

    private static _ManageDelegateDelegate _manageDelegate = _ManageDelegate;
    private static IntPtr _manageDelegatePtr = Marshal.GetFunctionPointerForDelegate(_manageDelegate);

    private static void _ManageDelegate(IntPtr ptr, int adjust)
    {
        lock (_ActiveDelegates)
        {
            var item = _ActiveDelegates[ptr];
            item.Item1 += adjust;
            if (item.Item1 > 0)
            {
                _ActiveDelegates[ptr] = item;
            }
            else
            {
                _ActiveDelegates.Remove(ptr);
            }
        }
    }

    private static _RawDelegate _AllocDelegate(Delegate d, Delegate original)
    {
        var ptr = Marshal.GetFunctionPointerForDelegate(d);
        lock (_ActiveDelegates)
        {
            if (_ActiveDelegates.ContainsKey(ptr))
            {
                var item = _ActiveDelegates[ptr];
                item.Item1 += 1;
                _ActiveDelegates[ptr] = item;
            }
            else
            {
                _ActiveDelegates.Add(ptr, (1, d, original));
            }
        }
        return new _RawDelegate
        {
            call_fn = ptr,
            drop_fn = _manageDelegatePtr,
        };
    }

    private static Delegate _FreeDelegate(_RawDelegate d)
    {
        var ptr = d.call_fn;
        lock (_ActiveDelegates)
        {
            var item = _ActiveDelegates[ptr];
            item.Item1 -= 1;
            if (item.Item1 > 0)
            {
                _ActiveDelegates[ptr] = item;
            }
            else
            {
                _ActiveDelegates.Remove(ptr);
            }
            return item.Item3;
        }
    }

    [DllImport("ctc_beam_decoder", EntryPoint = "rnet_alloc", CallingConvention = CallingConvention.Cdecl)]
    private static extern IntPtr _Alloc(UIntPtr size, UIntPtr align);

    [DllImport("ctc_beam_decoder", EntryPoint = "rnet_free", CallingConvention = CallingConvention.Cdecl)]
    private static extern void _Free(IntPtr ptr, UIntPtr size, UIntPtr align);

    [StructLayout(LayoutKind.Sequential)]
    private struct _RawSlice
    {
        public IntPtr ptr;
        public UIntPtr len;

        public static _RawSlice Alloc(UIntPtr len, int size, int align)
        {
            if (len == UIntPtr.Zero)
            {
                return new _RawSlice
                {
                    ptr = (IntPtr)align,
                    len = UIntPtr.Zero,
                };
            }
            else
            {
                return new _RawSlice
                {
                    ptr = _Alloc((UIntPtr)((UInt64)len * (UInt64)size), (UIntPtr)align),
                    len = len,
                };
            }
        }

        public void Free(int size, int align)
        {
            if (len != UIntPtr.Zero)
            {
                _Free(ptr, (UIntPtr)((UInt64)len * (UInt64)size), (UIntPtr)align);
                ptr = (IntPtr)1;
                len = UIntPtr.Zero;
            }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct _RawOpaqueHandle
    {
        public IntPtr ptr;
        public IntPtr drop_fn;
        public ulong type_id;

        public void Drop()
        {
            if (ptr != IntPtr.Zero)
            {
                var drop = Marshal.GetDelegateForFunctionPointer<_DropOpaqueDelegate>(drop_fn);
                drop(ptr);
                ptr = IntPtr.Zero;
            }
        }
    }

    private class _OpaqueHandle : IOpaqueHandle
    {
        private _RawOpaqueHandle inner;

        public _OpaqueHandle(_RawOpaqueHandle inner)
        {
            this.inner = inner;
        }

        public _RawOpaqueHandle ToInner(ulong type_id)
        {
            if (type_id != inner.type_id)
            {
                throw new InvalidCastException("Opaque handle does not have the correct type");
            }
            return this.inner;
        }

        ~_OpaqueHandle()
        {
            inner.Drop();
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as _OpaqueHandle);
        }

        public bool Equals(IOpaqueHandle other)
        {
            var casted = other as _OpaqueHandle;
            return casted != null &&
                   inner.ptr == casted.inner.ptr && inner.type_id == casted.inner.type_id;
        }

        public override int GetHashCode()
        {
            return inner.ptr.GetHashCode() + inner.type_id.GetHashCode();
        }

        public void Dispose()
        {
            inner.Drop();
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct _RawDelegate
    {
        public IntPtr call_fn;
        public IntPtr drop_fn;
    }

    private static IntPtr _AllocBox<T>(T arg, int size, int align)
    {
        if (size > 0)
        {
            var ptr = _Alloc((UIntPtr)size, (UIntPtr)align);
            Marshal.StructureToPtr(arg, ptr, false);
            return ptr;
        }
        else
        {
            return (IntPtr)align;
        }
    }

    private static _RawSlice _AllocStr(string arg)
    {
        var nb = Encoding.UTF8.GetByteCount(arg);
        var slice = _RawSlice.Alloc((UIntPtr)nb, 1, 1);
        unsafe
        {
            fixed (char* firstChar = arg)
            {
                nb = Encoding.UTF8.GetBytes(firstChar, arg.Length, (byte*)slice.ptr, nb);
            }
        }
        return slice;
    }

    private static _RawSlice _AllocSlice<T, U>(IReadOnlyCollection<T> collection, int size, int align, Func<T, U> converter)
    {
        var count = collection.Count;
        var slice = _RawSlice.Alloc((UIntPtr)count, size, align);
        var ptr = slice.ptr;
        foreach (var item in collection)
        {
            Marshal.StructureToPtr(converter(item), ptr, false);
            ptr = (IntPtr)(ptr.ToInt64() + (long)size);
        }
        return slice;
    }

    private static _RawSlice _AllocDict<TKey, TValue, U>(IReadOnlyDictionary<TKey, TValue> collection, int size, int align, Func<(TKey, TValue), U> converter) where U : unmanaged
    {
        var count = collection.Count;
        var slice = _RawSlice.Alloc((UIntPtr)count, size, align);
        var ptr = slice.ptr;
        foreach (var item in collection)
        {
            Marshal.StructureToPtr<U>(converter((item.Key, item.Value)), ptr, false);
            ptr = (IntPtr)(ptr.ToInt64() + (long)size);
        }
        return slice;
    }

    private static T _FreeBox<T>(IntPtr ptr, int size, int align)
    {
        var res = Marshal.PtrToStructure<T>(ptr);
        if (size > 0)
        {
            _Free(ptr, (UIntPtr)size, (UIntPtr)align);
        }
        return res;
    }

    private static String _FreeStr(_RawSlice arg)
    {
        unsafe
        {
            var res = Encoding.UTF8.GetString((byte*)arg.ptr, (int)arg.len);
            arg.Free(1, 1);
            return res;
        }
    }

    private static TList _FreeSlice<T, U, TList>(_RawSlice arg, int size, int align, Func<U, T> converter) where TList : ICollection<T>, new()
    {
        unsafe
        {
            var res = new TList();
            var ptr = arg.ptr;
            for (var i = 0; i < (int)arg.len; ++i)
            {
                res.Add(converter(Marshal.PtrToStructure<U>(ptr)));
                ptr = (IntPtr)(ptr.ToInt64() + (long)size);
            }
            arg.Free(size, align);
            return res;
        }
    }

    private static TDict _FreeDict<TKey, TValue, U, TDict>(_RawSlice arg, int size, int align, Func<U, (TKey, TValue)> converter) where U : unmanaged where TDict : IDictionary<TKey, TValue>, new()
    {
        unsafe
        {
            var res = new TDict();
            var ptr = arg.ptr;
            for (var i = 0; i < (int)arg.len; ++i)
            {
                var item = converter(Marshal.PtrToStructure<U>(ptr));
                res.Add(item.Item1, item.Item2);
                ptr = (IntPtr)(ptr.ToInt64() + (long)size);
            }
            arg.Free(size, align);
            return res;
        }
    }
}

#pragma warning restore CS8765, CS8767, CS8604, CS8607, CS8603